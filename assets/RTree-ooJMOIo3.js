var t=Object.defineProperty,__publicField=(i,e,n)=>((i,e,n)=>e in i?t(i,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):i[e]=n)(i,"symbol"!=typeof e?e+"":e,n);class RTree{constructor(t=9){__publicField(this,"_maxEntries"),__publicField(this,"_minEntries"),__publicField(this,"data"),this._maxEntries=Math.max(4,t),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),this.clear()}all(){return this._all(this.data,[])}allMap(){return this._allMap()}search(t,i=!1){let e=this.data;const n=[];if(!this.intersects(t,e))return n;const s=this.toBBox,h=[];for(;e;){for(let r=0;r<e.children.length;r++){const a=e.children[r],l=e.leaf?s(a):a;i?this.contains(t,l)?e.leaf?n.push(a):this._all(a,n):e.leaf?this.accurateCollisionFn(t,a)&&n.push(a):this.intersects(t,l)&&h.push(a):this.intersects(t,l)&&(e.leaf?n.push(a):this.contains(t,l)?this._all(a,n):h.push(a))}e=h.pop()}return n}searchAllIn(t){let i=this.data;const e=[];if(!this.intersects(t,i))return e;const n=this.toBBox,s=[];for(;i;){for(let h=0;h<i.children.length;h++){const r=i.children[h],a=i.leaf?n(r):r;this.contains(t,a)?i.leaf?e.push(r):this._all(r,e):this.intersects(t,a)&&(i.leaf||s.push(r))}i=s.pop()}return e}collides(t){let i=this.data;if(!this.intersects(t,i))return null;const e=[];for(;i;){for(let n=0;n<i.children.length;n++){const s=i.children[n],h=i.leaf?this.toBBox(s):s;if(this.contains(t,h))return i.leaf?s:findEntityInNode(s);if(i.leaf){if(this.accurateCollisionFn(t,s))return s}else this.intersects(t,h)&&e.push(s)}i=e.pop()}return null;function findEntityInNode(t){if(t.leaf)return t.children[0];return findEntityInNode(t.children[0])}}load(t){if(!(null==t?void 0:t.length))return this;if(t.length<this._minEntries){for(let i=0;i<t.length;i++)this.insert(t[i]);return this}let i=this._build(t.slice(),0,t.length-1,0);if(this.data.children.length)if(this.data.height===i.height)this._splitRoot(this.data,i);else{if(this.data.height<i.height){const t=this.data;this.data=i,i=t}this._insert(i,this.data.height-i.height-1,!0)}else this.data=i;return this}insert(t){return t&&this._insert(t,this.data.height-1),this}clear(){return this.data=this.createNode([]),this}remove(t,i=((t,i)=>t.id===i.id)){if(!t)return this;let e=this.data;const n=this.toBBox(t),s=[],h=[];let r,a,l;for(;e??s.length;){if(e||(e=s.pop(),a=s[s.length-1],r=h.pop(),l=!0),null==e?void 0:e.leaf){const n=this.findItem(t,e.children,i);if(-1!==n)return e.children.splice(n,1),s.push(e),this._condense(s),this}e&&!l&&!e.leaf&&this.contains(e,n)?(s.push(e),h.push(r),r=0,a=e,e=e.children[0]):a?(r++,e=a.children[r],l=!1):e=null}return this}toBBox(t){return t}compareMinX(t,i){return t.minX-i.minX}compareMinY(t,i){return t.minY-i.minY}accurateCollisionFn(t,i){throw new Error("accurateCollisionFn方法待实现！")}toJSON(){return this.data}fromJSON(t){return this.data=t,this}_all(t,i){const e=[];for(;t;)t.leaf?i.push(...t.children):e.push(...t.children),t=e.pop();return i}_allMap(){const t={};return function traverse(i){if(null==i?void 0:i.leaf)for(const e of i.children)e.id&&(t[e.id]=e);else for(const t of(null==i?void 0:i.children)??[])traverse(t)}(this.data),t}_build(t,i,e,n){const s=e-i+1;let h,r=this._maxEntries;if(s<=r)return h=this.createNode(t.slice(i,e+1)),this.calcBBox(h,this.toBBox),h;n||(n=Math.ceil(Math.log(s)/Math.log(r)),r=Math.ceil(s/Math.pow(r,n-1))),h=this.createNode([]),h.leaf=!1,h.height=n;const a=Math.ceil(s/r),l=a*Math.ceil(Math.sqrt(r));this.multiSelect(t,i,e,l,this.compareMinX);for(let o=i;o<=e;o+=l){const i=Math.min(o+l-1,e);this.multiSelect(t,o,i,a,this.compareMinY);for(let e=o;e<=i;e+=a){const s=Math.min(e+a-1,i);h.children.push(this._build(t,e,s,n-1))}}return this.calcBBox(h,this.toBBox),h}_chooseSubtree(t,i,e,n){for(;n.push(i),!i.leaf&&n.length-1!==e;){let e=1/0,n=1/0,s=null;for(let h=0;h<i.children.length;h++){const r=i.children[h],a=this.bboxArea(r),l=this.enlargedArea(t,r)-a;l<n?(n=l,e=a<e?a:e,s=r):l===n&&a<e&&(e=a,s=r)}i=s??i.children[0]}return i}_insert(t,i,e){const n=e?t:this.toBBox(t),s=[],h=this._chooseSubtree(n,this.data,i,s);for(h.children.push(t),this.extend(h,n);i>=0&&s[i].children.length>this._maxEntries;)this._split(s,i),i--;this._adjustParentBBoxes(n,s,i)}_split(t,i){const e=t[i],n=e.children.length,s=this._minEntries;this._chooseSplitAxis(e,s,n);const h=this._chooseSplitIndex(e,s,n),r=this.createNode(e.children.splice(h,e.children.length-h));r.height=e.height,r.leaf=e.leaf,this.calcBBox(e,this.toBBox),this.calcBBox(r,this.toBBox),i?t[i-1].children.push(r):this._splitRoot(e,r)}_splitRoot(t,i){this.data=this.createNode([t,i]),this.data.height=t.height+1,this.data.leaf=!1,this.calcBBox(this.data,this.toBBox)}_chooseSplitIndex(t,i,e){let n=null,s=1/0,h=1/0;for(let r=i;r<=e-i;r++){const i=this.distBBox(t,0,r,this.toBBox),a=this.distBBox(t,r,e,this.toBBox),l=this.intersectionArea(i,a),o=this.bboxArea(i)+this.bboxArea(a);l<s?(s=l,n=r,h=o<h?o:h):l===s&&o<h&&(h=o,n=r)}return n??e-i}_chooseSplitAxis(t,i,e){const n=t.leaf?this.compareMinX:this.compareNodeMinX,s=t.leaf?this.compareMinY:this.compareNodeMinY;this._allDistMargin(t,i,e,n)<this._allDistMargin(t,i,e,s)&&t.children.sort(n)}_allDistMargin(t,i,e,n){t.children.sort(n);const s=this.toBBox,h=this.distBBox(t,0,i,s),r=this.distBBox(t,e-i,e,s);let a=this.bboxMargin(h)+this.bboxMargin(r);for(let l=i;l<e-i;l++){const i=t.children[l];this.extend(h,t.leaf?s(i):i),a+=this.bboxMargin(h)}for(let l=e-i-1;l>=i;l--){const i=t.children[l];this.extend(r,t.leaf?s(i):i),a+=this.bboxMargin(r)}return a}_adjustParentBBoxes(t,i,e){for(let n=e;n>=0;n--)this.extend(i[n],t)}_condense(t){for(let i,e=t.length-1;e>=0;e--)0===t[e].children.length?e>0?(i=t[e-1].children,i.splice(i.indexOf(t[e]),1)):this.clear():this.calcBBox(t[e],this.toBBox)}findItem(t,i,e){if(!e)return i.indexOf(t);for(let n=0;n<i.length;n++)if(e(t,i[n]))return n;return-1}calcBBox(t,i){this.distBBox(t,0,t.children.length,i,t)}distBBox(t,i,e,n,s){s||(s=this.createNode([])),s.minX=1/0,s.minY=1/0,s.maxX=-1/0,s.maxY=-1/0;for(let h=i;h<e;h++){const i=t.children[h];this.extend(s,t.leaf?n(i):i)}return s}extend(t,i){return t.minX=Math.min(t.minX,i.minX),t.minY=Math.min(t.minY,i.minY),t.maxX=Math.max(t.maxX,i.maxX),t.maxY=Math.max(t.maxY,i.maxY),t}compareNodeMinX(t,i){return t.minX-i.minX}compareNodeMinY(t,i){return t.minY-i.minY}bboxArea(t){return(t.maxX-t.minX)*(t.maxY-t.minY)}bboxMargin(t){return t.maxX-t.minX+(t.maxY-t.minY)}enlargedArea(t,i){return(Math.max(i.maxX,t.maxX)-Math.min(i.minX,t.minX))*(Math.max(i.maxY,t.maxY)-Math.min(i.minY,t.minY))}intersectionArea(t,i){const e=Math.max(t.minX,i.minX),n=Math.max(t.minY,i.minY),s=Math.min(t.maxX,i.maxX),h=Math.min(t.maxY,i.maxY);return Math.max(0,s-e)*Math.max(0,h-n)}contains(t,i){return t.minX<=i.minX&&t.minY<=i.minY&&i.maxX<=t.maxX&&i.maxY<=t.maxY}intersects(t,i){return i.minX<=t.maxX&&i.minY<=t.maxY&&i.maxX>=t.minX&&i.maxY>=t.minY}createNode(t){return{children:t,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}multiSelect(t,i,e,n,s){const h=[i,e];for(;h.length;){if((e=h.pop())-(i=h.pop())<=n)continue;const r=i+Math.ceil((e-i)/n/2)*n;this.quickselect(t,r,i,e,s),h.push(i,r,r,e)}}quickselect(t,i,e,n,s){this.quickselectStep(t,i,e||0,n||t.length-1,s||this.defaultCompare)}quickselectStep(t,i,e,n,s){for(;n>e;){if(n-e>600){const h=n-e+1,r=i-e+1,a=Math.log(h),l=.5*Math.exp(2*a/3),o=.5*Math.sqrt(a*l*(h-l)/h)*(r-h/2<0?-1:1),c=Math.max(e,Math.floor(i-r*l/h+o)),m=Math.min(n,Math.floor(i+(h-r)*l/h+o));this.quickselectStep(t,i,c,m,s)}const h=t[i];let r=e,a=n;for(this.swap(t,e,i),s(t[n],h)>0&&this.swap(t,e,n);r<a;){for(this.swap(t,r,a),r++,a--;s(t[r],h)<0;)r++;for(;s(t[a],h)>0;)a--}0===s(t[e],h)?this.swap(t,e,a):(a++,this.swap(t,a,n)),a<=i&&(e=a+1),i<=a&&(n=a-1)}}swap(t,i,e){const n=t[i];t[i]=t[e],t[e]=n}defaultCompare(t,i){return t<i?-1:t>i?1:0}}export{RTree as R};
