var __defProp=Object.defineProperty,__defNormalProp=(t,e,i)=>e in t?__defProp(t,e,{enumerable:!0,configurable:!0,writable:!0,value:i}):t[e]=i,__publicField=(t,e,i)=>__defNormalProp(t,"symbol"!=typeof e?e+"":e,i);!function(){"use strict";const t=new WeakMap;function getMetadataMap(e,i){return t.get(e)&&t.get(e).get(i)}function ordinaryGetOwnMetadata(t,e,i){if(void 0===e)throw new TypeError;const n=getMetadataMap(e,i);return n&&n.get(t)}function ordinaryDefineOwnMetadata(e,i,n,r){if(r&&!["string","symbol"].includes(typeof r))throw new TypeError;(getMetadataMap(n,r)||function createMetadataMap(e,i){const n=t.get(e)||new Map;t.set(e,n);const r=n.get(i)||new Map;return n.set(i,r),r}(n,r)).set(e,i)}function ordinaryGetMetadata(t,e,i){return ordinaryGetOwnMetadata(t,e,i)?ordinaryGetOwnMetadata(t,e,i):Object.getPrototypeOf(e)?ordinaryGetMetadata(t,Object.getPrototypeOf(e),i):void 0}const e={decorate:function decorate(t,e,i,n){if(!Array.isArray(t)||0===t.length)throw new TypeError;return void 0!==i?function decorateProperty(t,e,i,n){return t.reverse().forEach((t=>{n=t(e,i,n)||n})),n}(t,e,i,n):"function"==typeof e?function decorateConstructor(t,e){return t.reverse().forEach((t=>{const i=t(e);i&&(e=i)})),e}(t,e):void 0},defineMetadata:function defineMetadata(t,e,i,n){ordinaryDefineOwnMetadata(t,e,i,n)},getMetadata:function getMetadata(t,e,i){return ordinaryGetMetadata(t,e,i)},getOwnMetadata:function getOwnMetadata(t,e,i){return ordinaryGetOwnMetadata(t,e,i)},hasMetadata:function hasMetadata(t,e,i){return!!ordinaryGetMetadata(t,e,i)},hasOwnMetadata:function hasOwnMetadata(t,e,i){return!!ordinaryGetOwnMetadata(t,e,i)},metadata:function metadata(t,e){return function decorator(i,n){ordinaryDefineOwnMetadata(t,e,i,n)}}};Object.assign(Reflect,e);class ArcCalculator{constructor(t,e,i,n,r=!1){__publicField(this,"points"),__publicField(this,"r"),__publicField(this,"startAngle"),__publicField(this,"endAngle"),__publicField(this,"anticlockwise"),this.points=[t],this.r=e,this.startAngle=i,this.endAngle=n,this.anticlockwise=r}static fromShape(t){if(!Array.isArray(t.points)||1!==t.points.length||void 0===t.r||void 0===t.startAngle||void 0===t.endAngle)throw new Error("Invalid shape data");return new ArcCalculator(t.points[0],t.r,t.startAngle,t.endAngle,t.anticlockwise)}static from3Points(t){if(3!==t.length)throw new Error("Exactly three points are required");const[e,i,n]=t,{xCenter:r,yCenter:s,r:a}=this.calculateCircle(e,i,n),o=this.angle(r,s,e[0],e[1]),c=this.angle(r,s,n[0],n[1]);return new ArcCalculator([r,s],a,o,c,function isAnticlockwise(t,e,i){const[n,r]=t,[s,a]=e,[o,c]=i;return(s-n)*(c-r)-(a-r)*(o-n)<0}(e,i,n))}static fromCenterStartEndPoint(t,e,i){const n=Math.sqrt((e[0]-t[0])**2+(e[1]-t[1])**2),r=Math.atan2(e[1]-t[1],e[0]-t[0]),s=Math.atan2(i[1]-t[1],i[0]-t[0]);return new ArcCalculator(t,n,r,s,!0)}static fromTangencyLine(t,e,i){const[n,r]=t,[s,a]=e,[o,c]=i,h=s-n,l=a-r,d=Math.sqrt(h*h+l*l),u=h/d,p=l/d,f=-p,g=(s+o)/2,m=(a+c)/2,x=((g-s)*f+(m-a)*u)/(f**2+u**2),M=g-x*f,A=m-x*u,y=Math.sqrt((M-s)**2+(A-a)**2),B=Math.atan2(a-A,s-M),E=Math.atan2(c-A,o-M);return new ArcCalculator([M,A],y,B,E,u*(c-a)-p*(o-s)<0)}static fromTangencyArc(t,e){const[i,n]=t.points[0],r=t.r,s=t.endAngle,a=t.anticlockwise,[o,c]=e,h=i+r*Math.cos(s),l=n+r*Math.sin(s),d=a?-(l-n):l-n,u=a?h-i:-(h-i),p=Math.sqrt(d**2+u**2),f=d/p,g=u/p,m=(h+o)/2,x=(l+c)/2,M=((m-h)*f+(x-l)*g)/(f**2+g**2),A=m-M*f,y=x-M*g,B=Math.sqrt((A-h)**2+(y-l)**2),E=Math.atan2(l-y,h-A),v=Math.atan2(c-y,o-A);return new ArcCalculator([A,y],B,E,v,f*(c-l)-g*(o-h)>0)}static calculateCircle(t,e,i){const[n,r]=t,[s,a]=e,[o,c]=i,h=2*(n*(a-c)+s*(c-r)+o*(r-a)),l=((n**2+r**2)*(a-c)+(s**2+a**2)*(c-r)+(o**2+c**2)*(r-a))/h,d=((n**2+r**2)*(o-s)+(s**2+a**2)*(n-o)+(o**2+c**2)*(s-n))/h;return{xCenter:l,yCenter:d,r:Math.sqrt((n-l)**2+(r-d)**2)}}static angle(t,e,i,n){return Math.atan2(n-e,i-t)}getCanvasArcParams(){return{points:this.points,r:this.r,startAngle:this.startAngle,endAngle:this.endAngle,anticlockwise:this.anticlockwise}}getArcAABB(){if(this.points&&this.points[0]&&this.r&&this.startAngle&&this.endAngle){let normalizeAngle=function(t){for(;t<0;)t+=2*Math.PI;for(;t>=2*Math.PI;)t-=2*Math.PI;return t};const t=this.points[0][0],e=this.points[0][1],i=normalizeAngle(this.startAngle),n=normalizeAngle(this.endAngle),minX=e=>t+this.r*Math.cos(e),minY=t=>e+this.r*Math.sin(t);let r=Math.min(minX(i),minX(n)),s=Math.max(minX(i),minX(n)),a=Math.min(minY(i),minY(n)),o=Math.max(minY(i),minY(n));const c=[0,Math.PI/2,Math.PI,3*Math.PI/2];for(const h of c){const t=normalizeAngle(h);(this.anticlockwise&&(i>=t&&t>=n||i<n&&(i>=t||t>=n))||!this.anticlockwise&&(i<=t&&t<=n||i>n&&(i<=t||t<=n)))&&(r=Math.min(r,minX(t)),s=Math.max(s,minX(t)),a=Math.min(a,minY(t)),o=Math.max(o,minY(t)))}return[[r,a],[s,o]]}return[]}getArcLengthCenterPoint(){if(!this.points||1!==this.points.length||void 0===this.r||void 0===this.startAngle||void 0===this.endAngle)throw new Error("Invalid shape data");const[t,e]=this.points[0],i=this.anticlockwise?(this.startAngle-this.endAngle+2*Math.PI)%(2*Math.PI):(this.endAngle-this.startAngle+2*Math.PI)%(2*Math.PI),n=this.anticlockwise?(this.startAngle-i/2+2*Math.PI)%(2*Math.PI):(this.startAngle+i/2)%(2*Math.PI);return[t+this.r*Math.cos(n),e+this.r*Math.sin(n)]}getArcLengthStartPoint(){if(!this.points||1!==this.points.length||void 0===this.r||void 0===this.startAngle)throw new Error("Invalid shape data");const[t,e]=this.points[0],i=this.r;return[t+i*Math.cos(this.startAngle),e+i*Math.sin(this.startAngle)]}getArcLengthEndPoint(){if(!this.points||1!==this.points.length||void 0===this.r||void 0===this.endAngle)throw new Error("Invalid shape data");const[t,e]=this.points[0],i=this.r;return[t+i*Math.cos(this.endAngle),e+i*Math.sin(this.endAngle)]}static getArcCenterPointByLine(t,e,i){const[n,r]=t,[s,a]=e,[o,c]=i,h=-(a-r),l=s-n,d=(s+o)/2,u=(a+c)/2,p=Math.sqrt((o-s)**2+(c-a)**2)/2;return[d+h*p/Math.sqrt(h**2+l**2),u+l*p/Math.sqrt(h**2+l**2)]}static getArcCenterPointByArc(t,e,i){if(3!==t.length)throw new Error("The previous arc must have exactly three points.");const[n,r,s]=t,{xCenter:a,yCenter:o}=this.calculateCircle(n,r,s),c=s[0]-a,h=s[1]-o,l=Math.sqrt(c**2+h**2),d=c/l,u=h/l,p=(e[0]+i[0])/2,f=(e[1]+i[1])/2,g=Math.sqrt((i[0]-e[0])**2+(i[1]-e[1])**2)/2;return[p+d*g,f+u*g]}}var i="inversify:tagged",n="inversify:tagged_props",r="inversify:paramtypes",s="Metadata key was used more than once in a parameter:",a="The @inject @multiInject @tagged and @named decorators must be applied to the parameters of a class constructor or a class property.",o=function(){function Metadata2(t,e){this.key=t,this.value=e}return Metadata2.prototype.toString=function(){return"named"===this.key?"named: "+String(this.value).toString()+" ":"tagged: { key:"+this.key.toString()+", value: "+String(this.value)+" }"},Metadata2}();function tagParameter(t,e,n,r){!function _throwIfMethodParameter(t){if(void 0!==t)throw new Error(a)}(e),_tagParameterOrProperty(i,t,n.toString(),r)}function _ensureNoMetadataKeyDuplicates(t){var e=[];if(Array.isArray(t)){var i=function getFirstArrayDuplicate(t){for(var e=new Set,i=0,n=t;i<n.length;i++){var r=n[i];if(e.has(r))return r;e.add(r)}}((e=t).map((function(t){return t.key})));if(void 0!==i)throw new Error(s+" "+i.toString())}else e=[t];return e}function _tagParameterOrProperty(t,e,i,n){var r=_ensureNoMetadataKeyDuplicates(n),a={};Reflect.hasOwnMetadata(t,e)&&(a=Reflect.getMetadata(t,e));var o=a[i];if(void 0===o)o=[];else for(var _loop_1=function(t){if(r.some((function(e){return e.key===t.key})))throw new Error(s+" "+t.key.toString())},c=0,h=o;c<h.length;c++){_loop_1(h[c])}o.push.apply(o,r),a[i]=o,Reflect.defineMetadata(t,a,e)}function createTaggedDecorator(t){return function(e,i,r){"number"==typeof r?tagParameter(e,i,r,t):function tagProperty(t,e,i){if(function targetIsConstructorFunction(t){return void 0!==t.prototype}(t))throw new Error(a);_tagParameterOrProperty(n,t.constructor,e,i)}(e,i,t)}}function injectable(){return function(t){if(Reflect.hasOwnMetadata(r,t))throw new Error("Cannot apply @injectable decorator multiple times.");var e=Reflect.getMetadata("design:paramtypes",t)||[];return Reflect.defineMetadata(r,e,t),t}}var c=function injectBase(t){return function(e){return function(i,n,r){if(void 0===e){var s="function"==typeof i?i.name:i.constructor.name;throw new Error("@inject called with undefined this could mean that the class "+s+" has a circular dependency problem. You can use a LazyServiceIdentifier to  overcome this limitation.")}return createTaggedDecorator(new o(t,e))(i,n,r)}}}("inject"),h=Object.getOwnPropertyDescriptor;let l=class{constructor(){__publicField(this,"list",new Map)}addEventListener(t,e){let i=this.list.get(t);i||(i=new Set,this.list.set(t,i)),i.has(e)||i.add(e)}dispatchEvent(t,...e){const i=this.list.get(t);if(i)for(const n of i)n(...e)}removeEventListener(t,e){const i=this.list.get(t);i&&i.has(e)&&i.delete(e)}once(t,e){const tempFn=(...i)=>{e(...i),this.removeEventListener(t,tempFn)};this.addEventListener(t,tempFn)}};l=((t,e,i,n)=>{for(var r,s=n>1?void 0:n?h(e,i):e,a=t.length-1;a>=0;a--)(r=t[a])&&(s=r(s)||s);return s})([injectable()],l);var d=Object.getOwnPropertyDescriptor;let u=class extends l{constructor(){super(),__publicField(this,"_dpr",1)}get dpr(){return this._dpr}setDpr(t){this._dpr=t}get ghostClearCompensation(){return 1*this._dpr}};u=((t,e,i,n)=>{for(var r,s=n>1?void 0:n?d(e,i):e,a=t.length-1;a>=0;a--)(r=t[a])&&(s=r(s)||s);return s})([injectable()],u);var p=Object.defineProperty,f=Object.getOwnPropertyDescriptor,__decorateClass$2=(t,e,i,n)=>{for(var r,s=n>1?void 0:n?f(e,i):e,a=t.length-1;a>=0;a--)(r=t[a])&&(s=(n?r(e,i,s):r(s))||s);return n&&s&&p(e,i,s),s};let g=class{constructor(){__publicField(this,"envConfig")}getAABB(t){let e=[];switch(t.type){case B.LINE:e=this.getLineAABB(t.shape[0]);break;case B.MTEXT:e=this.getMTextAABB(t.shape[0]);break;case B.CIRCLE:e=this.getCircleAABB(t.shape[0]);break;case B.ARC:e=this.getArcAABB(t.shape[0]);break;case B.PLINE:e=this.getPlineAABB(t.shape)}if(e.length){const t=this.envConfig.ghostClearCompensation;return[[e[0][0]-t,e[0][1]-t],[e[1][0]+t,e[1][1]+t]]}return e}getEntitiesAABB(t,e=!0){let i=1/0,n=1/0,r=-1/0,s=-1/0;return t.forEach((t=>{const a=e?this.getAABB(t):t.AABB??this.getAABB(t);if(2===a.length){const[t,e]=a[0],[o,c]=a[1];i=Math.min(i,t),n=Math.min(n,e),r=Math.max(r,o),s=Math.max(s,c)}})),[[i,n],[r,s]]}getLineAABB(t){try{const e=t.points,i=e[0][0],n=e[0][1],r=e[1][0],s=e[1][1],a=Math.min(i,r),o=Math.min(n,s),c=Math.max(i,r);return[[a,o],[c,Math.max(n,s)]]}catch(e){return[]}}getMTextAABB(t){try{return t.points}catch(e){return[]}}getCircleAABB(t){try{const e=t.points,i=e[0][0],n=e[0][1],r=t.r;return[[i-r,n-r],[i+r,n+r]]}catch(e){return[]}}getArcAABB(t){return ArcCalculator.fromShape(t).getArcAABB()}getPlineAABB(t){try{let e=1/0,i=1/0,n=-1/0,r=-1/0;return t.forEach((t=>{const s=t.points;switch(t.type){case B.LINE:s.forEach((([t,s])=>{e=Math.min(e,t),i=Math.min(i,s),n=Math.max(n,t),r=Math.max(r,s)}));case B.ARC:}})),[[e,i],[n,r]]}catch(e){return[]}}isRectInsideBoundingBox(t,e){const i=t[0][0],n=t[0][1],r=t[1][0],s=t[1][1];t=[[Math.min(i,r),Math.min(n,s)],[Math.max(i,r),Math.max(n,s)]];const[a,o]=e,[c,h]=t;return a[0]>=c[0]&&a[1]>=c[1]&&o[0]<=h[0]&&o[1]<=h[1]}isRectPartiallyInsideBoundingBox(t,e){const i=t[0][0],n=t[0][1],r=t[1][0],s=t[1][1];t=[[Math.min(i,r),Math.min(n,s)],[Math.max(i,r),Math.max(n,s)]];const[a,o]=e,[c,h]=t;return!(o[0]<c[0]||a[0]>h[0]||o[1]<c[1]||a[1]>h[1])}};__decorateClass$2([c(u)],g.prototype,"envConfig",2),g=__decorateClass$2([injectable()],g);const m=function generateUniqueIdFn(){function generateId(t){const e=new Uint8Array(Math.ceil(t/2));crypto.getRandomValues(e);let i="";for(let n=0;n<e.length;n++)i+=e[n].toString(16).padStart(2,"0");return i.slice(0,t)}const t={};return(e=6)=>{let i=generateId(e);for(;t[i];)i=generateId(e);return t[i]=!0,i}}();class Layer{constructor(){__publicField(this,"id",m()),__publicField(this,"status",!1),__publicField(this,"name",""),__publicField(this,"on",!0),__publicField(this,"frozen",!1),__publicField(this,"locked",!1),__publicField(this,"color","#fff"),__publicField(this,"lineType",""),__publicField(this,"lineWeight",0),__publicField(this,"printStyle","#fff"),__publicField(this,"print",!0),__publicField(this,"description",""),__publicField(this,"entityList",[])}}var x=Object.getOwnPropertyDescriptor;let M=class{constructor(){__publicField(this,"list",[]),this.layerInit()}layerInit(){0===this.list.length&&this.addLayer()}getList(){const t=this.list;if(0===t.length)throw new Error("没有任何图层存在！");return t}getCurrentLayer(){let t=this.list.find((t=>t.status));try{if(null==t)throw new Error("出现没有status为true的情况")}catch(e){this.list[0].status=!0,t=this.list[0]}return t}addLayer(){const t=new Layer;this.list.push(t)}removeLayerByIndex(t){if(!(t>-1&&t<this.list.length))throw new Error("无效的索引。");return this.list.splice(t,1),this.list}removeLayerById(t){return 1===this.list.length&&this.list[0].id===t?this.list:this.list.filter((e=>e.id!==t))}setLayerStatus(t){this.list.some((e=>e.id===t&&(e.status=!1,!0))),this.list.some((e=>e.id===t&&(e.status=!0,!0)))}delLayersByIds(t){return this.list.filter((e=>!t.includes(e.id)))}};M=((t,e,i,n)=>{for(var r,s=n>1?void 0:n?x(e,i):e,a=t.length-1;a>=0;a--)(r=t[a])&&(s=r(s)||s);return s})([injectable()],M);class RTree{constructor(t=9){__publicField(this,"_maxEntries"),__publicField(this,"_minEntries"),__publicField(this,"data"),this._maxEntries=Math.max(4,t),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),this.clear()}all(){return this._all(this.data,[])}allMap(){return this._allMap()}search(t,e=!1){let i=this.data;const n=[];if(!this.intersects(t,i))return n;const r=this.toBBox,s=[];for(;i;){for(let a=0;a<i.children.length;a++){const o=i.children[a],c=i.leaf?r(o):o;e?this.contains(t,c)?i.leaf?n.push(o):this._all(o,n):i.leaf?this.accurateCollisionFn(t,o)&&n.push(o):this.intersects(t,c)&&s.push(o):this.intersects(t,c)&&(i.leaf?n.push(o):this.contains(t,c)?this._all(o,n):s.push(o))}i=s.pop()}return n}searchAllIn(t){let e=this.data;const i=[];if(!this.intersects(t,e))return i;const n=this.toBBox,r=[];for(;e;){for(let s=0;s<e.children.length;s++){const a=e.children[s],o=e.leaf?n(a):a;this.contains(t,o)?e.leaf?i.push(a):this._all(a,i):this.intersects(t,o)&&(e.leaf||r.push(a))}e=r.pop()}return i}collides(t){let e=this.data;if(!this.intersects(t,e))return null;const i=[];for(;e;){for(let n=0;n<e.children.length;n++){const r=e.children[n],s=e.leaf?this.toBBox(r):r;if(this.contains(t,s))return e.leaf?r:findEntityInNode(r);if(e.leaf){if(this.accurateCollisionFn(t,r))return r}else this.intersects(t,s)&&i.push(r)}e=i.pop()}return null;function findEntityInNode(t){if(t.leaf)return t.children[0];return findEntityInNode(t.children[0])}}load(t){if(!(null==t?void 0:t.length))return this;if(t.length<this._minEntries){for(let e=0;e<t.length;e++)this.insert(t[e]);return this}let e=this._build(t.slice(),0,t.length-1,0);if(this.data.children.length)if(this.data.height===e.height)this._splitRoot(this.data,e);else{if(this.data.height<e.height){const t=this.data;this.data=e,e=t}this._insert(e,this.data.height-e.height-1,!0)}else this.data=e;return this}insert(t){return t&&this._insert(t,this.data.height-1),this}clear(){return this.data=this.createNode([]),this}remove(t,e=((t,e)=>t.id===e.id)){if(!t)return this;let i=this.data;const n=this.toBBox(t),r=[],s=[];let a,o,c;for(;i??r.length;){if(i||(i=r.pop(),o=r[r.length-1],a=s.pop(),c=!0),null==i?void 0:i.leaf){const n=this.findItem(t,i.children,e);if(-1!==n)return i.children.splice(n,1),r.push(i),this._condense(r),this}i&&!c&&!i.leaf&&this.contains(i,n)?(r.push(i),s.push(a),a=0,o=i,i=i.children[0]):o?(a++,i=o.children[a],c=!1):i=null}return this}toBBox(t){return t}compareMinX(t,e){return t.minX-e.minX}compareMinY(t,e){return t.minY-e.minY}accurateCollisionFn(t,e){throw new Error("accurateCollisionFn方法待实现！")}toJSON(){return this.data}fromJSON(t){return this.data=t,this}_all(t,e){const i=[];for(;t;)t.leaf?e.push(...t.children):i.push(...t.children),t=i.pop();return e}_allMap(){const t={};return function traverse(e){if(null==e?void 0:e.leaf)for(const i of e.children)i.id&&(t[i.id]=i);else for(const t of(null==e?void 0:e.children)??[])traverse(t)}(this.data),t}_build(t,e,i,n){const r=i-e+1;let s,a=this._maxEntries;if(r<=a)return s=this.createNode(t.slice(e,i+1)),this.calcBBox(s,this.toBBox),s;n||(n=Math.ceil(Math.log(r)/Math.log(a)),a=Math.ceil(r/Math.pow(a,n-1))),s=this.createNode([]),s.leaf=!1,s.height=n;const o=Math.ceil(r/a),c=o*Math.ceil(Math.sqrt(a));this.multiSelect(t,e,i,c,this.compareMinX);for(let h=e;h<=i;h+=c){const e=Math.min(h+c-1,i);this.multiSelect(t,h,e,o,this.compareMinY);for(let i=h;i<=e;i+=o){const r=Math.min(i+o-1,e);s.children.push(this._build(t,i,r,n-1))}}return this.calcBBox(s,this.toBBox),s}_chooseSubtree(t,e,i,n){for(;n.push(e),!e.leaf&&n.length-1!==i;){let i=1/0,n=1/0,r=null;for(let s=0;s<e.children.length;s++){const a=e.children[s],o=this.bboxArea(a),c=this.enlargedArea(t,a)-o;c<n?(n=c,i=o<i?o:i,r=a):c===n&&o<i&&(i=o,r=a)}e=r??e.children[0]}return e}_insert(t,e,i){const n=i?t:this.toBBox(t),r=[],s=this._chooseSubtree(n,this.data,e,r);for(s.children.push(t),this.extend(s,n);e>=0&&r[e].children.length>this._maxEntries;)this._split(r,e),e--;this._adjustParentBBoxes(n,r,e)}_split(t,e){const i=t[e],n=i.children.length,r=this._minEntries;this._chooseSplitAxis(i,r,n);const s=this._chooseSplitIndex(i,r,n),a=this.createNode(i.children.splice(s,i.children.length-s));a.height=i.height,a.leaf=i.leaf,this.calcBBox(i,this.toBBox),this.calcBBox(a,this.toBBox),e?t[e-1].children.push(a):this._splitRoot(i,a)}_splitRoot(t,e){this.data=this.createNode([t,e]),this.data.height=t.height+1,this.data.leaf=!1,this.calcBBox(this.data,this.toBBox)}_chooseSplitIndex(t,e,i){let n=null,r=1/0,s=1/0;for(let a=e;a<=i-e;a++){const e=this.distBBox(t,0,a,this.toBBox),o=this.distBBox(t,a,i,this.toBBox),c=this.intersectionArea(e,o),h=this.bboxArea(e)+this.bboxArea(o);c<r?(r=c,n=a,s=h<s?h:s):c===r&&h<s&&(s=h,n=a)}return n??i-e}_chooseSplitAxis(t,e,i){const n=t.leaf?this.compareMinX:this.compareNodeMinX,r=t.leaf?this.compareMinY:this.compareNodeMinY;this._allDistMargin(t,e,i,n)<this._allDistMargin(t,e,i,r)&&t.children.sort(n)}_allDistMargin(t,e,i,n){t.children.sort(n);const r=this.toBBox,s=this.distBBox(t,0,e,r),a=this.distBBox(t,i-e,i,r);let o=this.bboxMargin(s)+this.bboxMargin(a);for(let c=e;c<i-e;c++){const e=t.children[c];this.extend(s,t.leaf?r(e):e),o+=this.bboxMargin(s)}for(let c=i-e-1;c>=e;c--){const e=t.children[c];this.extend(a,t.leaf?r(e):e),o+=this.bboxMargin(a)}return o}_adjustParentBBoxes(t,e,i){for(let n=i;n>=0;n--)this.extend(e[n],t)}_condense(t){for(let e,i=t.length-1;i>=0;i--)0===t[i].children.length?i>0?(e=t[i-1].children,e.splice(e.indexOf(t[i]),1)):this.clear():this.calcBBox(t[i],this.toBBox)}findItem(t,e,i){if(!i)return e.indexOf(t);for(let n=0;n<e.length;n++)if(i(t,e[n]))return n;return-1}calcBBox(t,e){this.distBBox(t,0,t.children.length,e,t)}distBBox(t,e,i,n,r){r||(r=this.createNode([])),r.minX=1/0,r.minY=1/0,r.maxX=-1/0,r.maxY=-1/0;for(let s=e;s<i;s++){const e=t.children[s];this.extend(r,t.leaf?n(e):e)}return r}extend(t,e){return t.minX=Math.min(t.minX,e.minX),t.minY=Math.min(t.minY,e.minY),t.maxX=Math.max(t.maxX,e.maxX),t.maxY=Math.max(t.maxY,e.maxY),t}compareNodeMinX(t,e){return t.minX-e.minX}compareNodeMinY(t,e){return t.minY-e.minY}bboxArea(t){return(t.maxX-t.minX)*(t.maxY-t.minY)}bboxMargin(t){return t.maxX-t.minX+(t.maxY-t.minY)}enlargedArea(t,e){return(Math.max(e.maxX,t.maxX)-Math.min(e.minX,t.minX))*(Math.max(e.maxY,t.maxY)-Math.min(e.minY,t.minY))}intersectionArea(t,e){const i=Math.max(t.minX,e.minX),n=Math.max(t.minY,e.minY),r=Math.min(t.maxX,e.maxX),s=Math.min(t.maxY,e.maxY);return Math.max(0,r-i)*Math.max(0,s-n)}contains(t,e){return t.minX<=e.minX&&t.minY<=e.minY&&e.maxX<=t.maxX&&e.maxY<=t.maxY}intersects(t,e){return e.minX<=t.maxX&&e.minY<=t.maxY&&e.maxX>=t.minX&&e.maxY>=t.minY}createNode(t){return{children:t,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}multiSelect(t,e,i,n,r){const s=[e,i];for(;s.length;){if((i=s.pop())-(e=s.pop())<=n)continue;const a=e+Math.ceil((i-e)/n/2)*n;this.quickselect(t,a,e,i,r),s.push(e,a,a,i)}}quickselect(t,e,i,n,r){this.quickselectStep(t,e,i||0,n||t.length-1,r||this.defaultCompare)}quickselectStep(t,e,i,n,r){for(;n>i;){if(n-i>600){const s=n-i+1,a=e-i+1,o=Math.log(s),c=.5*Math.exp(2*o/3),h=.5*Math.sqrt(o*c*(s-c)/s)*(a-s/2<0?-1:1),l=Math.max(i,Math.floor(e-a*c/s+h)),d=Math.min(n,Math.floor(e+(s-a)*c/s+h));this.quickselectStep(t,e,l,d,r)}const s=t[e];let a=i,o=n;for(this.swap(t,i,e),r(t[n],s)>0&&this.swap(t,i,n);a<o;){for(this.swap(t,a,o),a++,o--;r(t[a],s)<0;)a++;for(;r(t[o],s)>0;)o--}0===r(t[i],s)?this.swap(t,i,o):(o++,this.swap(t,o,n)),o<=e&&(i=o+1),e<=o&&(n=o-1)}}swap(t,e,i){const n=t[e];t[e]=t[i],t[i]=n}defaultCompare(t,e){return t<e?-1:t>e?1:0}}class Vector2D{constructor(t,e){__publicField(this,"coordinates"),this.coordinates=new Float32Array([t,e])}static fromPoints(t,e){const[i,n]=t,[r,s]=e;return new Vector2D(r-i,s-n)}static fromArray(t){return new Vector2D(t[0],t[1])}static fromObject(t){return new Vector2D(t.x,t.y)}getMagnitude(){return Math.sqrt(this.coordinates[0]*this.coordinates[0]+this.coordinates[1]*this.coordinates[1])}getUnitVector(){const t=this.getMagnitude();if(0===t)throw new Error("Cannot calculate unit vector for a zero vector");return new Vector2D(this.coordinates[0]/t,this.coordinates[1]/t)}getDirectionDegrees(){return 180*Math.atan2(this.coordinates[1],this.coordinates[0])/Math.PI}add(t){return new Vector2D(this.coordinates[0]+t.coordinates[0],this.coordinates[1]+t.coordinates[1])}subtract(t){return new Vector2D(this.coordinates[0]-t.coordinates[0],this.coordinates[1]-t.coordinates[1])}scalarMultiply(t){return new Vector2D(this.coordinates[0]*t,this.coordinates[1]*t)}dotProduct(t){return this.coordinates[0]*t.coordinates[0]+this.coordinates[1]*t.coordinates[1]}crossProduct(t){return this.coordinates[0]*t.coordinates[1]-this.coordinates[1]*t.coordinates[0]}getAngleRadians(t){const e=this.dotProduct(t),i=this.getMagnitude()*t.getMagnitude();return Math.acos(e/i)}projectOnto(t){const e=this.dotProduct(t)/t.getMagnitude()**2;return t.scalarMultiply(e)}rotate(t){const e=Math.cos(t),i=Math.sin(t),n=this.coordinates[0]*e-this.coordinates[1]*i,r=this.coordinates[0]*i+this.coordinates[1]*e;return new Vector2D(n,r)}translate(t,e){return new Vector2D(this.coordinates[0]+t,this.coordinates[1]+e)}isEqual(t){return this.coordinates[0]===t.coordinates[0]&&this.coordinates[1]===t.coordinates[1]}getNormalVector(){return new Vector2D(-this.coordinates[1],this.coordinates[0])}isCollidingWith(t,e){return this.subtract(t).getMagnitude()<=e}}class LineCalculator{constructor(t,e){__publicField(this,"points"),this.points=[t,e]}getMidPoint(){const[t,e]=this.points,[i,n]=t,[r,s]=e;return[(i+r)/2,(n+s)/2]}getPerpendicularPoint(t){const[e,i]=this.points,[n,r]=t,[s,a]=e,[o,c]=i,h=o-s,l=c-a,d=((n-s)*h+(r-a)*l)/(h*h+l*l);return d<0||d>1?null:[s+d*h,a+d*l]}getPointToLineDistance(t){const[e,i]=this.points,[n,r]=t,[s,a]=e,[o,c]=i,h=c-a,l=s-o,d=o*a-s*c;return Math.abs(h*n+l*r+d)/Math.sqrt(h*h+l*l)}getPointToSegmentNearest(t){const[e,i]=this.points,[n,r]=t,[s,a]=e,[o,c]=i,h=o-s,l=c-a;let d=((n-s)*h+(r-a)*l)/(h*h+l*l);d=Math.max(0,Math.min(1,d));return[s+d*h,a+d*l]}isIntersectSegment(t,e){const i=Vector2D.fromArray(this.points[0]),n=Vector2D.fromArray(this.points[1]),r=Vector2D.fromArray(t),s=Vector2D.fromArray(e),a=r.subtract(i).crossProduct(n.subtract(i)),o=s.subtract(i).crossProduct(n.subtract(i)),c=i.subtract(r).crossProduct(s.subtract(r)),h=n.subtract(r).crossProduct(s.subtract(r));return a*o<0&&c*h<0}getIntersectSegment(t,e){const[i,n]=this.points,[r,s]=[t,e],[a,o]=i,[c,h]=n,[l,d]=r,[u,p]=s,f=(p-d)*(c-a)-(u-l)*(h-o);if(0===f)return null;const g=((u-l)*(o-d)-(p-d)*(a-l))/f,m=((c-a)*(o-d)-(h-o)*(a-l))/f;if(g<0||g>1||m<0||m>1)return null;return[a+g*(c-a),o+g*(h-o)]}getIntersectCircle(t,e){const[i,n]=this.points,[r,s]=t,[a,o]=i,[c,h]=n,l=c-a,d=h-o,u=l*l+d*d,p=2*(l*(a-r)+d(o-s)),f=p*p-4*u*(r*r+s*s+a*a+o*o-2*(r*a+s*o)-e*e);if(f<0)return null;const g=Math.sqrt(f),m=(-p+g)/(2*u),x=(-p-g)/(2*u),M=[];return m>=0&&m<=1&&M.push([a+m*l,o+m*d]),x>=0&&x<=1&&M.push([a+x*l,o+x*d]),M.length?M:null}getIntersectArc(t,e,i,n,r=!1){const s=this.getIntersectCircle(t,e);if(!s)return null;const[a,o]=t,c=s.map((([t,e])=>Math.atan2(e-o,t-a))),h=c.map(((t,e)=>(t=>{let e=t;return t<i&&(e+=2*Math.PI),r?e<=i&&e>=n:e>=i&&e<=n})(t)?s[e]:null)).filter((t=>null!==t));return h.length?h:null}}class RectangleCalculator{constructor(t,e){__publicField(this,"points"),this.points=[t,e]}isPointInside(t){const[e,i]=this.points,[n,r]=t;return n>=e[0]&&n<=i[0]&&r>=e[1]&&r<=i[1]}isIntersectSegment(t,e){const[i,n]=this.points,r=[[i,[n[0],i[1]]],[i,[i[0],n[1]]],[n,[i[0],n[1]]],[n,[n[0],i[1]]]];let s=new LineCalculator(t,e);for(const a of r)if(s.isIntersectSegment(a[0],a[1]))return!0;return!1}isIntersectRectangleEdge(t,e){const i=t,n=e,r=[[i,[n[0],i[1]]],[i,[i[0],n[1]]],[n,[i[0],n[1]]],[n,[n[0],i[1]]]];for(const s of r)if(this.isIntersectSegment(s[0],s[1]))return!0;return!1}isIntersectRectangle(t,e){const[i,n]=this.points,[r,s]=[t,e];return!(i[0]>s[0]||n[0]<r[0]||i[1]>s[1]||n[1]<r[1])}isIntersectCircle(t,e){const[i,n]=t,[[r,s],[a,o]]=this.points,isPointOnCircleEdge=(t,e,i,n,r)=>{const s=(t-i)**2+(e-n)**2;return Math.abs(s-r*r)<1e-6},isPointInsideRectangle=(t,e,i,n,r,s)=>t>=i&&t<=r&&e>=n&&e<=s,doesLineSegmentIntersectCircle=(t,e,i,n,r,s,a)=>{const o=s-n,c=a-r,h=n-t,l=r-e,d=o*o+c*c,u=2*(h*o+l*c);let p=u*u-4*d*(h*h+l*l-i*i);if(p<0)return!1;p=Math.sqrt(p);const f=(-u-p)/(2*d),g=(-u+p)/(2*d);return f>=0&&f<=1||g>=0&&g<=1},c=i-Math.max(r,Math.min(i,a)),h=n-Math.max(s,Math.min(n,o));if(c*c+h*h>e*e)return!1;const l=[[r,s],[a,s],[a,o],[r,o]],d=[[l[0],l[1]],[l[1],l[2]],[l[2],l[3]],[l[3],l[0]]];for(const[[p,f],[g,m]]of d)if(doesLineSegmentIntersectCircle(i,n,e,p,f,g,m))return!0;for(const[p,f]of l)if(isPointOnCircleEdge(p,f,i,n,e))return!0;const u=[[i+e,n],[i-e,n],[i,n+e],[i,n-e]];for(const[p,f]of u)if(isPointInsideRectangle(p,f,r,s,a,o))return!0;return!1}isIntersectCircleAndCenter(t,e){return this.isIntersectCircle(t,e)||this.isPointInside(t)}isIntersectArc(t,e,i,n,r){const[s,a]=t,[[o,c],[h,l]]=this.points;function normalizeAngle(t){for(;t<0;)t+=2*Math.PI;for(;t>=2*Math.PI;)t-=2*Math.PI;return t}if(i=normalizeAngle(i),n=normalizeAngle(n),r){const t=i;i=n,n=t}function isAngleInArcRange(t,e,i){return e<i?t>=e&&t<=i:t>=e||t<=i}const d=[[o,c],[h,c],[h,l],[o,l]],u=[[d[0],d[1]],[d[1],d[2]],[d[2],d[3]],[d[3],d[0]]],doesLineSegmentIntersectArc=(t,e,i,n,r,s,a,o,c)=>{const h=i-t,l=n-e,d=t-r,u=e-s,p=h*h+l*l,f=2*(d*h+u*l);let g=f*f-4*p*(d*d+u*u-a*a);if(g<0)return!1;g=Math.sqrt(g);const m=(-f-g)/(2*p),x=(-f+g)/(2*p);if(m>=0&&m<=1){const i=t+m*h,n=e+m*l;if(isAngleInArcRange(normalizeAngle(Math.atan2(n-s,i-r)),o,c))return!0}if(x>=0&&x<=1){const i=t+x*h,n=e+x*l;if(isAngleInArcRange(normalizeAngle(Math.atan2(n-s,i-r)),o,c))return!0}return!1};for(const[[p,f],[g,m]]of u)if(doesLineSegmentIntersectArc(p,f,g,m,s,a,e,i,n))return!0;return!1}}var A=Object.defineProperty,y=Object.getOwnPropertyDescriptor,__decorateClass=(t,e,i,n)=>{for(var r,s=n>1?void 0:n?y(e,i):e,a=t.length-1;a>=0;a--)(r=t[a])&&(s=(n?r(e,i,s):r(s))||s);return n&&s&&A(e,i,s),s},B=(t=>(t.LINE="LINE",t.CONSTRUCTION="CONSTRUCTION",t.PLINE="PLINE",t.ARC="ARC",t.CIRCLE="CIRCLE",t.SPLINE="SPLINE",t.ELLIPSE="ELLIPSE",t.BLOCK="BLOCK",t.POINT="POINT",t.HELIX="HELIX",t.HATCH="HATCH",t.REGION="REGION",t.TABLE="TABLE",t.MTEXT="MTEXT",t))(B||{});const E="ADD",v="EDIT",_="DELETE";let w=class extends l{constructor(){super(),__publicField(this,"layerComtainer"),__publicField(this,"boundingBox"),__publicField(this,"entityRTree"),__publicField(this,"_derivedData",{selectionBoxEntities:[],collisionEntity:null}),this.EntityRTreeInit()}get selectionBoxEntities(){return this._derivedData.selectionBoxEntities}get collisionEntity(){return this._derivedData.collisionEntity}all(){return this.entityRTree.all()}toJSON(){return this.entityRTree.toJSON()}getEntityById(t){return this.entityRTree.all().find((e=>e.id===t))}cursorCollisionDetect(t){return this.entityRTree.collides({minX:t[0][0],minY:t[0][1],maxX:t[1][0],maxY:t[1][1]})}getEntityByAABB(t,e=!1){return this.entityRTree.search({minX:t[0][0],minY:t[0][1],maxX:t[1][0],maxY:t[1][1]},e)}getEntityByAABBAllIn(t){return this.entityRTree.searchAllIn({minX:t[0][0],minY:t[0][1],maxX:t[1][0],maxY:t[1][1]})}addEntityData(t){t=t.map((t=>(t.AABB=this.boundingBox.getAABB(t),t.layer=this.layerComtainer.getCurrentLayer(),t))),this.entityRTree.load(t),this.updateDerivedData(0,t),this.dispatchEvent(E,t)}editEntitiesData(t){const e=this.boundingBox.getEntitiesAABB(t,!1);console.time("纯数据更新"),t.forEach((t=>{const e=t.AABB,i=this.boundingBox.getAABB(t);e&&e[0][0]===i[0][0]&&e[0][1]===i[0][1]&&e[1][0]===i[1][0]&&e[1][1]===i[1][1]||(this.entityRTree.remove(t),t.AABB=i,this.entityRTree.insert(t))})),console.timeEnd("纯数据更新"),console.log(`更新数量：${t.length}`),this.updateDerivedData(1,t),this.dispatchEvent(v,t,{oldAABB:e})}delEntityData(t){const e=this.boundingBox.getEntitiesAABB(t,!1);t.forEach((t=>{this.entityRTree.remove(t)})),this.updateDerivedData(2,t),this.dispatchEvent(_,t,{oldAABB:e})}EntityRTreeInit(){this.entityRTree=new EntityRTree(4)}updateDerivedData(t,e){console.time("DerivedDataUpdatedType.EDIT"),this.updateSelectionBoxEntities(t,e),this.updateCollisionEntity(t,e),console.timeEnd("DerivedDataUpdatedType.EDIT")}updateSelectionBoxEntities(t,e){if(e.length>10||this._derivedData.selectionBoxEntities.length>10)this._derivedData.selectionBoxEntities=this.entityRTree.all().filter((t=>{var e;return null==(e=t.other)?void 0:e.boxSelected}));else if(2===t)this._derivedData.selectionBoxEntities=this._derivedData.selectionBoxEntities.filter((t=>!(e.findIndex((e=>e.id===t.id))>-1)));else e.forEach((t=>{var e;if(null==(e=t.other)?void 0:e.boxSelected){const e=this._derivedData.selectionBoxEntities.findIndex((e=>t.id===e.id));e>-1?this._derivedData.selectionBoxEntities[e]=t:this._derivedData.selectionBoxEntities.push(t)}else this._derivedData.selectionBoxEntities=this._derivedData.selectionBoxEntities.filter((e=>e.id!==t.id))}))}updateCollisionEntity(t,e){this._derivedData.collisionEntity=e.find((t=>{var e;return null==(e=t.other)?void 0:e.collisioned}))}};__decorateClass([c(M)],w.prototype,"layerComtainer",2),__decorateClass([c(g)],w.prototype,"boundingBox",2),w=__decorateClass([injectable()],w);class EntityRTree extends RTree{constructor(){super(...arguments),__publicField(this,"boundingBox")}toBBox(t){let e=t.AABB;return e||(e=this.boundingBox.getAABB(t),t.AABB=e),{...t,minX:e[0][0],minY:e[0][1],maxX:e[1][0],maxY:e[1][1]}}compareMinX(t,e){return t.AABB[0][0]-e.AABB[0][0]}compareMinY(t,e){return t.AABB[0][1]-e.AABB[0][1]}accurateCollisionFn(t,e){const i=[[t.minX,t.minY],[t.maxX,t.maxY]];return e.shape.some((t=>{switch(t.type){case"LINE":return new RectangleCalculator(i[0],i[1]).isIntersectSegment(t.points[0],t.points[1]);case"MTEXT":return new RectangleCalculator(i[0],i[1]).isIntersectRectangleEdge(t.points[0],t.points[1]);case"CIRCLE":if(Array.isArray(t.points)&&t.r)return new RectangleCalculator(i[0],i[1]).isIntersectCircleAndCenter(t.points[0],t.r);break;case"ARC":if(Array.isArray(t.points)&&t.r&&t.startAngle&&t.endAngle)return new RectangleCalculator(i[0],i[1]).isIntersectArc(t.points[0],t.r,t.startAngle,t.endAngle,t.anticlockwise)}return!1}))}}__decorateClass([c(g)],EntityRTree.prototype,"boundingBox",2);class Shape{constructor(t){__publicField(this,"ctx"),this.ctx=t}createBatch(t){t.forEach((t=>{this.create(t)}))}create(t){switch(t.type){case B.LINE:case B.MTEXT:case B.CIRCLE:case B.ARC:this.createMetaShape(t.shape[0]);break;case B.PLINE:t.shape.forEach((t=>{this.createMetaShape(t)}))}}createMetaShape(t){switch(t.type){case B.LINE:this.line(t);break;case B.MTEXT:this.mtext(t);break;case B.CIRCLE:this.circle(t);break;case B.ARC:this.arc(t)}}line(t){const e=t.points;if(e.length<2)return;this.ctx.save(),this.setStyle(t);const i=e[0][0],n=e[0][1],r=e[1][0],s=e[1][1];this.ctx.beginPath(),this.ctx.moveTo(i,n),this.ctx.lineTo(r,s),this.ctx.stroke(),this.ctx.closePath(),this.ctx.restore()}mtext(t){const e=t.points;if(e.length<2)return;this.ctx.save(),this.setStyle(t);const i=e[0][0],n=e[0][1],r=e[1][0],s=e[1][1];this.ctx.beginPath(),this.ctx.moveTo(i,n),this.ctx.lineTo(r,n),this.ctx.lineTo(r,s),this.ctx.lineTo(i,s),this.ctx.lineTo(i,n),this.ctx.stroke(),this.ctx.closePath(),this.ctx.restore()}circle(t){const e=t.points;if(e.length<1)return;this.ctx.save(),this.setStyle(t);const i=e[0][0],n=e[0][1],r=t.r;this.ctx.beginPath(),this.ctx.arc(i,n,r,0,2*Math.PI),this.ctx.stroke(),this.ctx.closePath(),this.ctx.restore()}arc(t){const e=t.points,i=e[0][0],n=e[0][1],r=t.r,s=t.startAngle,a=t.endAngle,o=t.anticlockwise;if(!e||1!==e.length||void 0===r||void 0===s||void 0===a)throw new Error("Invalid shape data");this.ctx.save(),this.setStyle(t),this.ctx.beginPath(),this.ctx.arc(i,n,r,s,a,o),this.ctx.stroke(),this.ctx.closePath(),this.ctx.restore()}setStyle(t){t.color&&(this.ctx.strokeStyle=t.color),t.lineWidth&&(this.ctx.lineWidth=t.lineWidth),t.lineDash&&this.ctx.setLineDash(t.lineDash)}}new class Render{constructor(){__publicField(this,"offscreenCanvas"),__publicField(this,"osCtx"),__publicField(this,"dpr"),__publicField(this,"selectedNodeSize"),__publicField(this,"shape"),__publicField(this,"isProgressiveRenderRunning",!1),__publicField(this,"canProgressiveRenderBeStop",!1),this.addEventListenerInit()}addEventListenerInit(){self.addEventListener("message",(t=>{const e=t.data||{};switch(e.event){case"INIT":this.dpr=e.dpr,this.selectedNodeSize=e.selectedNodeSize||12,this.offscreenCanvas=e.canvas,this.osCtx=this.offscreenCanvas.getContext("2d"),this.osCtx.strokeStyle="#fff",this.osCtx.lineWidth=1*this.dpr,this.osCtx.save(),this.shapeInit();break;case"RENDER":this.renderEntityArr(e);break;case"PROCESSRENDER":this.isProgressiveRenderRunning&&e.stopPrevProcessRender?this.canProgressiveRenderBeStop=!0:this.canProgressiveRenderBeStop=!1,this.progressiveRender(e);break;case"CLEAR":Array.isArray(e.clearArea)&&this.clearRect(e.clearArea)}}))}shapeInit(){this.shape=new Shape(this.osCtx)}renderEntityArr(t){const{a:e,b:i,c:n,d:r,e:s,f:a}=t.viewInfo;this.osCtx.setTransform(e,i,n,r,s,a),this.osCtx.lineWidth=this.dpr/e;const o=t.entityArr,c=1/e,h=1/r;for(const d of o)if(d.other){const{collisioned:t,boxSelected:e}=d.other;if(t||e){const e=t?[c,3*h]:[5*c,5*h];for(const t of d.shape)t.lineDash=e}}try{this.shape.createBatch(o)}catch(l){throw new Error("visual绘制异常！")}t.renderShapeSelectedNode&&this.drawShapeSelectedNode(o,t.viewInfo)}progressiveRender(t){const{a:e,b:i,c:n,d:r,e:s,f:a}=t.viewInfo;this.osCtx.setTransform(e,i,n,r,s,a),this.osCtx.lineWidth=this.dpr/e;const o=t.entityArr,c=1/e,h=1/r;for(const u of o)if(u.other){const{collisioned:t,boxSelected:e}=u.other;if(t||e){const e=t?[c,3*h]:[5*c,5*h];for(const t of u.shape)t.lineDash=e}}let l=1e3;let d=0;this.isProgressiveRenderRunning=!0;const step=()=>{if(this.canProgressiveRenderBeStop)return this.isProgressiveRenderRunning=!1,this.canProgressiveRenderBeStop=!1,void self.postMessage({event:"PROCESSRENDERFINISHED"});const t=performance.now(),e=o.slice(d,d+l);d+=e.length,this.shape.createBatch(e);const i=performance.now()-t;l=i>16?Math.max(100,Math.floor(.85*l)):Math.min(3e3,Math.floor(1.15*l)),d<o.length?requestAnimationFrame(step):(this.isProgressiveRenderRunning=!1,this.canProgressiveRenderBeStop=!1,self.postMessage({event:"PROCESSRENDERFINISHED"}))};step()}drawShapeSelectedNode(t,e){t.forEach((t=>{var i;(null==(i=t.other)?void 0:i.boxSelected)&&t.shape.forEach((t=>{var i;switch(t.type){case B.LINE:if(null==(i=t.points)||i.forEach((t=>{this.drawSelectedNode(t,e)})),t.points&&t.points.length>=2){const i=[(t.points[1][0]+t.points[0][0])/2,(t.points[1][1]+t.points[0][1])/2];this.drawSelectedNode(i,e)}break;case B.MTEXT:{let i=[];Array.isArray(t.points)&&(i=[t.points[0],[t.points[1][0],t.points[0][1]],t.points[1],[t.points[0][0],t.points[1][1]]]),i.forEach((t=>{this.drawSelectedNode(t,e)}));break}case B.CIRCLE:if(Array.isArray(t.points)&&t.r){const i=t.points[0];this.drawSelectedNode(i,e),this.drawSelectedNode([i[0]+t.r,i[1]],e),this.drawSelectedNode([i[0],i[1]-t.r],e),this.drawSelectedNode([i[0]-t.r,i[1]],e),this.drawSelectedNode([i[0],i[1]+t.r],e)}break;case B.ARC:if(Array.isArray(t.points)&&t.r&&t.startAngle&&t.endAngle){const i=ArcCalculator.fromShape(t),n=t.points[0];this.drawSelectedNode(n,e),this.drawSelectedNode(i.getArcLengthStartPoint(),e),this.drawSelectedNode(i.getArcLengthCenterPoint(),e),this.drawSelectedNode(i.getArcLengthEndPoint(),e)}}}))}))}drawSelectedNode(t,e){const{a:i,d:n}=e,r=this.selectedNodeSize/i,s=this.selectedNodeSize/n;this.osCtx.save(),this.osCtx.fillStyle="blue",this.osCtx.fillRect(t[0]-r/2,t[1]-s/2,r,s),this.osCtx.restore()}clearRect(t){const{a:e,d:i,e:n,f:r}=this.osCtx.getTransform();this.osCtx.clearRect((t[0][0]-n)/e,(t[0][1]-r)/i,(t[1][0]-t[0][0])/e,(t[1][1]-t[0][1])/i)}clearAll(){const{a:t,d:e,e:i,f:n}=this.osCtx.getTransform();this.osCtx.clearRect((0-i)/t,(0-n)/e,this.osCtx.canvas.width/t,this.osCtx.canvas.height/e)}}}();
